/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * classifyImage.c
 *
 * Code generation for function 'classifyImage'
 *
 */

/* Include files */
#include "/home/agustin/Code/Matlab/ClasesDoc/AlgoritmosGeneticos/codegen/lib/classifyImage/detectObjectCPP/classifyImage.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const double myNetwork[190] =
    {
        -0.000714517494493762, -0.382282751401072, -0.0651423257251430, 0.00210083436089171, 1.01435860524299, -1.63856350949947, -0.00595799496756799, -0.638022258613817, 0.00496265109841017, 1.56693870355804, 0.00111247315431267, -0.0114135689402448, 0.00903027706868129, -1.11059124229584, -3.04476846859938, 1.32550084029287, 1.94017066543415, -2.85510028850632, 0.00224556663986284, -0.799593831988099, 1.70314523758833, -0.000122058402210541, 0.000112373677409566, -0.883406860968865, 0.00219320674672233, 0.00319711321070062, 0.00653043525436664, -0.00782323256353990, -0.0220348897832777, -1.37760740210187, 0.743939547326502, -0.000264142451251041, -0.0101829159591027, 0.00146661194600747, -3.35811652101438, -0.00281563443310201, -2.71133495035006, -0.271235438413085, -0.645650352684419, -0.00335536482867785, 1.15337114516134, 0.00363556640357079, 0.00461256365729232, -1.40131470097624, -0.0407731639206119, 0.260533891827677, 0.00197765859870142, -1.21521427214198, -0.238976102269815, -0.0129560711443235, -1.03206504247154, 2.42178360311068, 0.000258393070897759, -0.00761303750041698, 0.00467613909228783, -1.54720252843334, -0.0202040942823233, -0.872959059950898, 0.00414499206160137, 1.27144001138401, -0.00457699413554704, 0.0127232799828312, -0.0159306461785079, 0.0226320841501821, 0.00196305383239475, -0.000149554687198621, -0.857559712120811, -0.159030716930868, -0.00900992278742376, -0.00923076602473342, -0.267968971291119, 0.000701356416319548, -0.0623720511422376, -0.0531701974857788, -0.0195231491541267, 0.0222815350331330, -0.0119577419673332, -0.000328428868794014, -0.0330256793865676, -3.31693037319439e-06, -1.58252937116903, 0.0582988443573022, -0.812580983373174, 0.00519475253066624, 0.644438691799240, -1.17236181163564, 0.405212481029474, 1.35609604934409, 0.705365402286983, -0.841228787943069, 0.0194676949868342, -1.57953696932469, 0.529788596486042, -0.00197929406849372, 1.26806929831159, -0.906498568205155, 0.473636754683785, -0.0776634914454591, -4.51134515619830e-05, 0.327082521342065, 2.81812128402619, -1.07452893234820, 0.661056107067874, 0.0338192406934121, 0.0204261117846353, 0.660990710100850, -0.709352106764142, -0.0441795617360916, 1.21929320956662, -0.000158578474069548, 1.05357097800438, 0.591368965234355, -0.00851089556871052, -0.0125029748702220, -0.242878105456532, -0.0402771168344066, 0.0799486386162004, -0.00345595218425734, -0.000457627954814431, -0.957707258246977, -0.00151861024891058, -0.787931894000903, 0.00695186356465840, -0.00160232252864808, 0.0131483386757690, 1.55020308741514, 0.400906597879831, 0.0317995655282348, 0.00106636092752605, 0.0351094871978930, -0.00840090845223394, -1.38933056339833, 1.02558469383700, -0.0726923392409117, -0.113636847891485, 0.0592029775036201, -0.843615024012117, -1.80906780713657, -1.25760020461805, 0.0607432946016296, 2.08037495667328, 3.95607722105619e-05, -6.16866371763030e-05, -0.000941241712663057, -0.303110267152517, 0.239032794356834, -3.15466733891067, 0.0641093791614267, -0.00512864654571240, 1.22227242351378, 1.25056870410901, 0.00497430301689734, -0.000581467249393908, -0.517395898959843, -0.215707191939006, 0.00204090309260518, 0.0165212553359181, 8.29650816001296e-05, -0.0521483447046643, 0.129922461892052, 1.54363972354499, 1.24791691192413, 0.508954874636231, -0.464677695499374, 0.868523184101042, -0.784082039938669, 1.09278953421195, -0.756139464316385, -0.330297192329072, 0.970297820612084, -0.765826113607305, 0.990927259488444, -0.524420177795245, -0.0181310372137045, 0.866890848757905, 0.841473253608118, -0.000191214243908648, -9.30676023464940e-07, 1.02765236171400, 5.31516032886057e-05, 0.237365940553492, -1.68379949145173, -0.000416461513431278, 0.000170778891412622, -2.90288711483971, 0.418576225317532, 1.99996972617009, 1.68389865350527, -1.76419451181903, 0.960760317621250};

/* Function Definitions */
double classifyImageProcessing(const unsigned char myImage[7500]) {
    double x[7500];
    double b_myNetwork[160];
    double pp[16];
    double b_v5_tmp;
    double v5;
    double v6;
    double v7;
    int b_v1;
    int b_v2;
    int v1;
    int v2;
    int v3;
    int v5_tmp;
    int v5_tmp_tmp;
    int v8;
    for (v8 = 0; v8 < 7500; v8++) {
        x[v8] = (double)myImage[v8] / 255.0 - 0.5;
    }
    /* variables */
    /* init stage 1 */
    for (v1 = 0; v1 < 23; v1++) {
        b_v1 = (v1 << 1) + 2;
        for (v2 = 0; v2 < 23; v2++) {
            b_v2 = (v2 << 1) + 2;
            v5 = 0.0;
            v6 = 0.0;
            v7 = 0.0;
            v8 = 181;
            /* for v3 = 1:maskH */
            /* for v4 = 1:maskW */
            for (v3 = 0; v3 < 3; v3++) {
                v5_tmp_tmp = b_v1 + v3;
                v5_tmp = v5_tmp_tmp + 50 * (b_v2 - 1);
                v5 += x[v5_tmp - 1] * myNetwork[v8];
                v6 += x[v5_tmp + 2499] * myNetwork[v8];
                v7 += x[v5_tmp + 4999] * myNetwork[v8];
                v5_tmp = v5_tmp_tmp + 50 * b_v2;
                b_v5_tmp = myNetwork[v8 + 1];
                v5 += x[v5_tmp - 1] * b_v5_tmp;
                v6 += x[v5_tmp + 2499] * b_v5_tmp;
                v7 += x[v5_tmp + 4999] * b_v5_tmp;
                v5_tmp = v5_tmp_tmp + 50 * (b_v2 + 1);
                b_v5_tmp = myNetwork[v8 + 2];
                v5 += x[v5_tmp - 1] * b_v5_tmp;
                v6 += x[v5_tmp + 2499] * b_v5_tmp;
                v7 += x[v5_tmp + 4999] * b_v5_tmp;
                v8 += 3;
            }
            v8 = b_v1 + 50 * b_v2;
            x[v8] = v5;
            x[v8 + 2500] = v6;
            x[v8 + 5000] = v7;
        }
    }
    /* tabla de 4 x 4 */
    memset(&pp[0], 0, 16U * sizeof(double));
    v8 = 0;
    for (v1 = 0; v1 < 4; v1++) {
        b_v1 = v1 * 12;
        for (v2 = 0; v2 < 4; v2++) {
            b_v2 = v2 * 12;
            v5 = x[b_v1 + 50 * b_v2];
            for (v3 = 2; v3 < 433; v3++) {
                v5 += x[((b_v1 + (v3 - 1) % 12) + 50 * (b_v2 + (v3 - 1) / 12 % 12)) +
                        2500 * ((v3 - 1) / 144)];
            }
            pp[v8 + v2] = v5;
        }
        v8 += 4;
    }
    /*  end stage 1 */
    for (v8 = 0; v8 < 16; v8++) {
        pp[v8] *= 0.01;
    }
    memcpy(&b_myNetwork[0], &myNetwork[0], 160U * sizeof(double));
    v5 = 0.0;
    for (v3 = 0; v3 < 10; v3++) {
        v6 = 0.0;
        for (v8 = 0; v8 < 16; v8++) {
            v6 += b_myNetwork[v3 + 10 * v8] * pp[v8];
        }
        v5 +=
            myNetwork[v3 + 160] * (1.0 / (exp(-(v6 + myNetwork[v3 + 170])) + 1.0));
    }
    return v5 + myNetwork[180];
}

double classifyImage(const unsigned char myImage[7500]) {
    unsigned char myImageVector[7500];
    int contador = 0;
    for (int i = 0; i < 50; i++) {
        for (int j = 0; j < 50; j++) {
            myImageVector[contador] = image.at<cv::Vec3b>(j, i)[2];
            contador++;
        }
    }
    for (int i = 0; i < 50; i++) {
        for (int j = 0; j < 50; j++) {
            myImageVector[contador] = image.at<cv::Vec3b>(j, i)[1];
            contador++;
        }
    }
    for (int i = 0; i < 50; i++) {
        for (int j = 0; j < 50; j++) {
            myImageVector[contador] = image.at<cv::Vec3b>(j, i)[0];
            contador++;
        }
    }

    double y = classifyImageProcessing(myImageVector);
    return y;
}

// int main() {
//     Mat image;
//     image = imread("/home/agustin/Code/Matlab/ClasesDoc/AlgoritmosGeneticos/Pictures/c1/img_048.png");
//     if (!image.data) {
//         printf("No image data \n");
//         return -1;
//     }
//     // namedWindow("Display Image", WINDOW_AUTOSIZE);
//     // imshow("Display Image", image);
//     // waitKey(0);

//     resize(image, image, Size(50, 50));

//     // Cambiar a formato MATLAB
//     unsigned char myImageVector[7500];
//     int contador = 0;
//     for (int i = 0; i < 50; i++) {
//         for (int j = 0; j < 50; j++) {
//             myImageVector[contador] = image.at<cv::Vec3b>(j, i)[2];
//             contador++;
//         }
//     }
//     for (int i = 0; i < 50; i++) {
//         for (int j = 0; j < 50; j++) {
//             myImageVector[contador] = image.at<cv::Vec3b>(j, i)[1];
//             contador++;
//         }
//     }
//     for (int i = 0; i < 50; i++) {
//         for (int j = 0; j < 50; j++) {
//             myImageVector[contador] = image.at<cv::Vec3b>(j, i)[0];
//             contador++;
//         }
//     }

//     std::cout << image;

//     double y = classifyImage(myImageVector);
//     printf("%f\n", y);
//     return 0;
// }

/* End of code generation (classifyImage.c) */
